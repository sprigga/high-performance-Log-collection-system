# 效能對比測試指南

## 📚 概述

本專案包含兩個系統實作，用於比較不同架構設計對效能的影響：

1. **優化系統**（原系統）：採用負載平衡、連接池、Redis 快取、非同步處理等優化技術
2. **對照組**（簡化系統）：直接寫入 PostgreSQL，無任何優化機制

---

## 🏗️ 系統架構對比

### 優化系統架構

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│    Nginx    │ ← 負載平衡
└──────┬──────┘
       │
       ├─────────────┬─────────────┐
       ▼             ▼             ▼
┌──────────┐  ┌──────────┐  ┌──────────┐
│FastAPI-1 │  │FastAPI-2 │  │ Worker   │
└────┬─────┘  └────┬─────┘  └────┬─────┘
     │             │              │
     └─────────────┴──────────────┘
                   │
         ┌─────────┴─────────┐
         ▼                   ▼
    ┌────────┐         ┌──────────┐
    │ Redis  │         │PostgreSQL│
    │Stream  │         │          │
    │Cache   │         └──────────┘
    └────────┘
```

**關鍵特性**：
- ✅ Nginx 負載平衡器（輪詢分配請求）
- ✅ 2 個 FastAPI 實例（水平擴展）
- ✅ SQLAlchemy 連接池（pool_size=10, max_overflow=5）
- ✅ Redis Stream 非同步處理（解耦寫入）
- ✅ Redis 快取層（查詢加速）
- ✅ 獨立 Worker 批量寫入資料庫

### 簡化系統架構（對照組）

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  FastAPI    │ ← 單一實例
└──────┬──────┘
       │
       │ 每次請求創建新連線
       ▼
┌─────────────┐
│ PostgreSQL  │
└─────────────┘
```

**關鍵特性**：
- ❌ 無負載平衡
- ❌ 單一 FastAPI 實例
- ❌ 無連接池（每次請求創建新連線）
- ❌ 無快取層
- ❌ 同步阻塞式寫入
- ❌ 無非同步處理

---

## 🚀 執行測試

### 1. 測試優化系統

```bash
# 啟動優化系統
cd /home/ubuntu/log-collection-system
docker compose up -d --build

# 等待系統就緒
sleep 10

# 執行壓力測試
uv run python tests/stress_test.py

# 停止系統
docker compose down
```

**端點**：
- API: http://localhost:18723
- Prometheus: http://localhost:19090
- Grafana: http://localhost:13000

### 2. 測試對照組（簡化系統）

```bash
# 啟動對照組
cd /home/ubuntu/log-collection-system/control-group
docker compose -f docker-compose-simple.yml up -d --build

# 等待系統就緒
sleep 10

# 執行壓力測試
uv run python stress_test_simple.py

# 停止系統
docker compose -f docker-compose-simple.yml down
```

**端點**：
- API: http://localhost:18724

### 3. 使用自動化腳本（推薦）

```bash
# 對照組自動化測試
cd /home/ubuntu/log-collection-system/control-group
./run_test.sh
```

---

## 📊 測試配置

兩個系統使用相同的測試參數以確保公平比較：

```python
NUM_DEVICES = 100           # 設備數量
LOGS_PER_DEVICE = 100       # 每台設備發送的日誌數
TOTAL_LOGS = 10,000         # 總日誌數
CONCURRENT_LIMIT = 200      # 並發限制
BATCH_SIZE = 5              # 批次大小
NUM_ITERATIONS = 500        # 測試循環次數
```

---

## 🎯 效能指標

### 關鍵指標說明

| 指標 | 說明 | 目標值 |
|------|------|--------|
| **吞吐量** | 每秒處理的日誌數 | ≥ 10,000 logs/秒 |
| **平均回應時間** | 所有請求的平均回應時間 | < 50 ms |
| **P50 回應時間** | 50% 請求的回應時間 | < 50 ms |
| **P95 回應時間** | 95% 請求的回應時間 | < 100 ms |
| **P99 回應時間** | 99% 請求的回應時間 | < 200 ms |
| **失敗率** | 失敗請求佔總請求的百分比 | 0% |
| **總耗時** | 完成所有請求的總時間 | 越短越好 |

---

## 📈 預期效能差異

### 優化系統（預期）

- ✅ 吞吐量: ~10,000-15,000 logs/秒
- ✅ P95 回應時間: < 100 ms
- ✅ 失敗率: 0%
- ✅ 總耗時: ~1 秒

### 簡化系統（預期）

- ⚠️ 吞吐量: ~2,000-5,000 logs/秒
- ⚠️ P95 回應時間: > 200 ms
- ⚠️ 失敗率: 可能 > 0%（高並發下）
- ⚠️ 總耗時: ~3-5 秒

### 預期改善幅度

- **吞吐量**: 提升 200-400%
- **P95 回應時間**: 降低 50-70%
- **總耗時**: 減少 70-80%

---

## 🔍 效能瓶頸分析

### 簡化系統的主要瓶頸

#### 1. 連線管理開銷 ⚠️

**問題**：
- 每次請求都需要建立新的 PostgreSQL 連線
- 連線建立耗時約 10-50ms
- 連線關閉也需要時間

**影響**：
- 高並發下頻繁創建/關閉連線
- 資源浪費嚴重

**優化系統解決方案**：
- 使用 SQLAlchemy 連接池
- 保持常駐連線（pool_size=10）
- 動態擴展（max_overflow=5）

#### 2. 同步阻塞 🚫

**問題**：
- 每個請求必須等待資料庫寫入完成才能返回
- 寫入操作阻塞請求處理

**影響**：
- 回應時間長
- 並發能力受限

**優化系統解決方案**：
- Redis Stream 非同步寫入
- 快速返回（< 5ms）
- Worker 背景處理

#### 3. 無快取層 📦

**問題**：
- 查詢必須訪問資料庫
- 重複查詢造成資源浪費

**影響**：
- 查詢效能差
- 資料庫負載高

**優化系統解決方案**：
- Redis 快取查詢結果
- TTL 5分鐘
- Cache Hit Rate > 80%

#### 4. 單一實例 🔄

**問題**：
- CPU 和記憶體資源受限
- 無法水平擴展

**影響**：
- 吞吐量上限低
- 單點故障風險

**優化系統解決方案**：
- Nginx 負載平衡
- 2 個 FastAPI 實例
- 輪詢分配請求

#### 5. 資料庫壓力 💾

**問題**：
- 所有寫入直接衝擊資料庫
- 高並發可能達到連線數上限

**影響**：
- 資料庫成為瓶頸
- 可能出現連線失敗

**優化系統解決方案**：
- Redis Stream 緩衝
- Worker 批量寫入
- 降低資料庫壓力 90%+

---

## 📝 測試結果記錄範本

### 測試環境

- **CPU**: _____
- **記憶體**: _____
- **作業系統**: Linux WSL2
- **Docker 版本**: _____
- **測試日期**: _____
- **測試人員**: _____

### 效能對比表

| 指標 | 優化系統 | 簡化系統 | 改善幅度 |
|------|---------|---------|---------|
| 吞吐量 (logs/秒) | _____ | _____ | _____% |
| 平均回應時間 (ms) | _____ | _____ | _____% |
| P50 回應時間 (ms) | _____ | _____ | _____% |
| P95 回應時間 (ms) | _____ | _____ | _____% |
| P99 回應時間 (ms) | _____ | _____ | _____% |
| 失敗率 (%) | _____ | _____ | _____% |
| 總耗時 (秒) | _____ | _____ | _____% |

### 資源使用對比

| 資源 | 優化系統 | 簡化系統 |
|------|---------|---------|
| CPU 使用率 (%) | _____ | _____ |
| 記憶體使用 (MB) | _____ | _____ |
| 資料庫連線數 | _____ | _____ |
| 網路流量 (MB) | _____ | _____ |

---

## 🛠️ 使用比較分析工具

```bash
cd /home/ubuntu/log-collection-system/control-group

# 執行比較分析（使用範例數據）
uv run python compare_results.py
```

**輸出範例**：

```
================================================================================
  📊 效能比較分析報告
================================================================================

⚡ 吞吐量 (logs/秒)
--------------------------------------------------------------------------------
  優化系統:   12500.00 logs/秒
  簡化系統:    3500.00 logs/秒
  改善幅度:     257.14% ✅

⏱️  平均回應時間 (ms)
--------------------------------------------------------------------------------
  優化系統:      45.50 ms
  簡化系統:     180.00 ms
  改善幅度:      74.72% ✅

...

  🏆 綜合評分
  總體改善:     185.50%
  評級: ⭐⭐⭐⭐⭐ 優秀
```

---

## 💡 最佳實踐建議

### 1. 測試前準備

- ✅ 清理舊資料（`docker compose down -v`）
- ✅ 確保系統資源充足
- ✅ 關閉其他佔用資源的程序
- ✅ 使用相同的測試參數

### 2. 執行測試

- ✅ 執行多次取平均值（建議 3-5 次）
- ✅ 觀察系統資源使用情況
- ✅ 記錄詳細的測試日誌
- ✅ 截圖保存關鍵指標

### 3. 結果分析

- ✅ 比較各項效能指標
- ✅ 分析瓶頸原因
- ✅ 驗證優化效果
- ✅ 記錄改善建議

---

## 📚 參考文檔

- [優化系統監控文檔](docs/MONITORING.md)
- [Nginx 配置說明](docs/NGINX-FASTAPI.md)
- [對照組 README](control-group/README.md)
- [壓力測試說明](tests/stress_test.py)

---

## 🎓 學習要點

透過此對比測試，您可以學習到：

1. **連接池的重要性**
   - 避免頻繁創建/關閉連線
   - 提升資源利用率

2. **非同步處理的優勢**
   - 解耦寫入操作
   - 快速回應用戶

3. **快取層的價值**
   - 減少資料庫壓力
   - 加速查詢效能

4. **負載平衡的作用**
   - 水平擴展能力
   - 提升吞吐量

5. **架構設計的影響**
   - 好的架構能帶來數倍效能提升
   - 需要權衡複雜度與效能

---

## ⚠️ 注意事項

1. **公平比較**
   - 使用相同的 PostgreSQL 配置
   - 相同的測試參數
   - 相同的測試環境

2. **資源限制**
   - 簡化系統可能無法承受高並發
   - 建議從較小的並發數開始測試
   - 逐步增加負載

3. **真實場景**
   - 測試結果僅供參考
   - 實際效能取決於具體場景
   - 建議結合業務需求評估

---

## 📞 問題回報

如有任何問題或建議，請：

1. 查看相關文檔
2. 檢查系統日誌
3. 提交 Issue
4. 尋求技術支援
